# 汇编考前复习

## 求补码

### 正数

正整数的补码是其二进制表示，与原码相同 。
【例1】+9的补码是00001001。（备注：这个+9的补码是用8位2进制来表示的，补码表示方式很多，还有16位二进制补码表示形式，以及32位二进制补码表示形式,64位进制补码表示形式等。每一种补码表示形式都只能表示有限的数字。）

### 负数

求负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1。
同一个数字在不同的补码表示形式中是不同的。比如-15的补码，在8位二进制中是11110001，然而在16位二进制补码表示中，就是1111111111110001。以下都使用8位2进制来表示。
【例2】求-5的补码。

**<font color="red">-5对应正数5 </font>**（00000101）→所有位取反（11111010）→加1(11111011)
所以-5的补码是11111011。
【例3】数0的补码表示是唯一的。
[+0]补=[+0]反=[+0]原=00000000
[-0]补=11111111+1=00000000

### 转化为原码

已知一个数的补码，求原码的操作其实就是对该补码再求补码：

⑴如果补码的符号位为“0”，表示是一个正数，其原码就是补码。

⑵如果补码的符号位为“1”，表示是一个负数，那么求给定的这个补码的补码就是要求的原码。

【例4】已知一个补码为11111001，则原码是10000111（-7）。

因为符号位为“1”，表示是一个负数，所以该位不变，仍为“1”。

其余七位1111001取反后为0000110；

再加1，所以是10000111。

### 补码的绝对值

补码的绝对值
【例5】-65的补码是10111111
若直接将10111111转换成十进制，发现结果并不是-65，而是191。
事实上，在计算机内，如果是一个二进制数，其最左边的位是1，则我们可以判定它为负数，并且是用补码表示。
**<font color="red">若要得到一个负二进制补码的数值，只要对补码全部取反并加1，就可得到其数值。 </font>**
如：二进制值：10111111（-65的补码）
各位取反：01000000
加1：01000001（+65）

## 进制转换

### 与十进制

（1）二进制转十进制

方法：“按权展开求和”

【例】：

 ![img](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D347/sign=33ef79cbc995d143de76e22744f18296/4bed2e738bd4b31cf649017386d6277f9f2ff885.jpg)

规律：个位上的数字的次数是0，十位上的数字的次数是1，......，依次递增，而十分位的数字的次数是-1，百分位上数字的次数是-2，......，依次递减。

注意：不是任何一个十进制小数都能转换成有限位的二进制数。

（2）十进制转二进制

· 十进制整数转二进制数：“除以2取余，逆序排列”（除二取余法）

【例】：

 ![img](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D142/sign=8d76a90f9152982201333dc7e5cb7b3b/0dd7912397dda1446661f97ab3b7d0a20df4868a.jpg)

89÷2 ……1

44÷2 ……0

22÷2 ……0

11÷2 ……1

5÷2 ……1

2÷2 ……0

1

##  零位扩展和符号位扩展

### 符号扩展

**当用更多的内存存储某一个有符号数时**，由于符号位位于该数的第一位，扩展之后，符号位仍然需要位于第一位，所以，当扩展一个负数的时候需要将扩展的高位全赋为1；对于正数而言，符号扩展和零扩展是一样的，因为符号位就是0。

比如一个用一个8位二进制表示-1，则是10000001

如果把这个书用16位二进制表示时，则为11111111 10000001 高位全都是1，这个叫做符号扩展，主要用于对其操作数。

### **零扩展就是全补零**

不论其符号位是多少，高8位全都补0.

能过上面的定义可以看出在C++中，如果把一个char向一个整形转换的时候，就会存在着这个问题

如果你想得到一个正数，那么如果一个字符的ASCII码值是小于零的，而直接用(int)c进行强制类型转换，结果是通过符号扩展得到的也为一个负数。要得到正数，一定要用(int)(unsigned char)c;因为unsigned char去除了c的符号位，所以，这样的类型转换后，再用(int)进行转换得到的就是一个正数。

### 分析

从上机的叙述得知，有符号数向其它类型数据转化(如char到int,char到unsigned int)时，进行符号位扩展；无符号数向其它类型转换(如unsigned char到int, long)时，进行零扩展。

| char          | short          | 符号位扩展                                       |
| ------------- | -------------- | ------------------------------------------------ |
| char          | unsigned char  | 最高位失去符号位意义，变为数据位                 |
| char          | unsigned short | 符号位扩展到short;然后从short转到 unsigned short |
| unsigned char | char           | 最高位作为符号位                                 |
| unsigned char | short          | 0扩展                                            |
| unsigned char | float          | 转换到long; 再从 long 转换到float                |

### 由大数据类型向小数据类型转换时，保留低位字节。

| unsigned long | char  | 保留低位字节 |
| ------------- | ----- | ------------ |
| unsigned long | short | 保留低位字节 |

## 记不住的指令整理

* xor	异或运算

* shl	按位左移
  * shl是一个汇编指令，作用是逻辑左移指令，将目的操作数顺序左移1位或CL寄存器中指定的位数。**左移一位时，操作数的最高位移入进位标志位CF，最低位补零。**
  * SHR指令将目的操作数顺序右移1位或CL寄存器指定的位数。逻辑右移1位时，**目的操作数的最低位移到进位标志位CF,最高位补零。**
  * 等价命令：sal
  
* shr与sar

  * 汇编语言中SAR和SHR指令都是右移指令，SAR是算数右移指令（shift arithmetic right），而SHR是逻辑右移指令（shift logical right）。
  * 两者的区别在于SAR右移时保留操作数的符号，即用符号位来补足，而SHR右移时总是用0来补足。
  * 例如10000000算数右移（SAR）一位是11000000，而逻辑右移（SHR）一位是01000000

* rcl、rcr：带进位循环左移、带进位循环右移
  
  * RCL AL，1则把AL的最高位1送给CF，使CF=1，AL其它位相应左移，成为 0100 000X，最后空下的X位被CF原来的值补齐；
    同样，ROL AL，CL（CL=2），相当于2次 RCL AL，1，最后AL变成 1000 00X1，AL原第二位的0到了CF，CF原来的值补AL中的x。
  * RCR AX,1 ;先用进位标志CF填补AX空出的1位，然后将AX最右边的1位移进CF
  
* ror、rol	循环左移、循环右移
  
  * rol——循环左移指令：`ROL DEST，COUNT`
    指令功能：把目的地址中的数据循环左移COUNT次，每次从最高位（最左）移出的数据位都补充到最低位（最右），**最后从最高位（最左）移出的数据位保存到CF标志位。**
    标志位影响：CF标志用于保存最后从最高位移出的数据位。**如果COUNT=1，OF标志有意义，如果移位前后数据的符号位发生了变化，OF=1；如果符号位没有发生变化，OF=0。如果COUNT>1，OF标志不确定（没有意义）。**
  * ror 是循环右移指令，被移出的位，补回到最左端。
    ror al,cl 就是将al的内容，向右循环移位cl指定的位数。如cl=3,就表示移位3次。
* **似乎不能在最后可以跟一个数字，也可以rol一个寄存器**
	
> 与、或、异或运算可以用来改变某些位的值
  
* xchg
  交换指令XCHG是两个寄存器，寄存器和内存变量之间内容的交换指令，两个操作数的数据类型要相同，可以是一个字节，也可以是一个字，也可以是双字

* les【不要求】
  LES( load ES)指令的功能是：把内存中指定位置的双字操作数的低位字装入指令中指定的寄存器、高位字装入ES寄存器。

* cbw
  AL符号扩展为AX。在8086中CBW指令将AL的最高有效位D7扩展至AH，即：如果AL的最高有效位是0，则AH = 00；AL的最高有效位为1，则AH = FFH。AL不变。（即将AL的符号位移至AH）

  CBW属符号扩展指令，它可以把8位扩展到16位，扩展前后两数的真值不变，主要用于数据类型不同时用符号扩展指令可以使得数据类型相同。

* cwd
  是汇编语言中的字扩展指令，它的功能是将一个字型变量扩展为双字型变量。
  就是把AX的符号位去填充DX

* adc:带进位加法

* neg：求相反数，会影响CF、ZF、SF等标志位

  ```assembly
  mov ax,0FFFEh
  neg ax
  ```

  在代码运行结束后CF=1

  `neg ax==(not ax)+1	;对二进制求反再加一`

* sbb 带借位减

* jg：SF==OF

* jl：SF!=OF

* rep：循环执行cx次字符串操作指令

* stosb、stosw：把AL或AX中的数据装入ES:DI指向的存储单元，然后根据DF标志增减DI(di++或di--)

* lodsb、lodsw：把DS:SI指向的存储单元中的数据装入AL或AX，然后根据DF标志增减SI

* 关于转移指令

  * JGB是大于或等于，JLE是小于或等于
  * A（above）大于，B（below）小于，E（equal）等于，用于比较无符号数
  * G（great）大于，L（less than）小于， E（equal）等于，用于比较带符号数

* repne scasb指令，用于扫描字符串，计算字符串的长度，如下两条指令：

  ```assembly
  cld
  repne scasb
  ```

  对应的等价指令是：

  ```assembly
  scans:inc edi
      dec ecx
      je loopdone
      cmp byte [edi-1],al
  loopdone:
  ```

  * 对比：repe：扫描到字符则退出。

* 串传送指令
  格式：movsb
  功能：

  （1）、（（es）*16+（di））=（（ds）*16+（si））
  （2）、如果df=0，则：（si）=（si）+1
  　　　（di）=（di）+1
  　　　  如果df=1，则；（si）=（si）-1
  　　　（di）=（di）-1
  当然也可以传送一个字，movsw，增量为2
  一般来说，movsb，movsw都和rep配合使用，用汇编语法来描述rep movsb的功能就是：

  ```assembly
  s：movsb
  　  loop s
  ```


  可见，rep的作用是根据cx的值，重复执行后面的串传送指令。

## 跳转指令和它的机器码

### 短跳

两个字节

第一个字节=EB

第二个字节=目标地址-下一条指令偏移地址

### 近跳

第一个字节=E9

第二个（含第三个）字节=目标地址-下一条指令偏移地址

记得按照小端规则颠倒算出的差值填入命令

### 远跳

例如，jmp 1234h:5678h，应该表示为

```assembly
db 0EAh
dw 5678h
dw 1234h
```

## 寄存器们

### FL标志寄存器

#### CF	进位标志，借位标志

左移和右移出去的1位会填到CF上，与CF相关的两条跳转指令jc、jnc、clc、stc、cmc

```assembly
clc;使CF=0，clear carry flag
stc;使CF=1，set carry flag
cmc;使CF反转，complement carry flag
jb;jump if below
jc;jump if carry flag
;上述两条指令等价
```

inc和dec指令不影响CF标志位

#### ZF	零标志

#### OF	溢出标志

**<font color="red">溢出两种情况：正数相加得到负数、负数相加得到正数 </font>**

*注意：8位寄存器加法运算溢出时要把原先运算结果减去100h*

**溢出标志OF用于反映有符号数加减运算所得结果是否溢出.如果运算结果超过当前运算位数所能表示的范围,则称为溢出,OF的值被置为1,否则,OF的值被清为0.**

`of是溢出标志位,SF是符号标志位. `

* 如果OF为零,说明没有溢出,那么逻辑上真正的结果的正负等于实际结果的正负. 
  如果SF为1,那么实际结果为负,所以逻辑上真正的结果为负.
  -45-5=-50
* 如果OF为1,说明有溢出,那么逻辑上真正的结果的正负不等于实际结果的正负. 
  如果SF为0,那么实际结果为正,由前面“逻辑上真正的结果的正负不等于实际结果的正负”可知,逻辑上真正的结果应该为负. 
  可得出结论：如果因为溢出导致了实际结果为正,那么逻辑上真正的结果必然为负. 
  十进制 十六进制 
  -45-100=-145 
  mov al,-45 mov al,D3 
  add al,-100 add al,9C 
  al的值应为-145, al的值为 6f(111) ,二进制表示为01101111, 
  8位二进制能表达的数据范围-128至127,of=1 因此,sf=0,因为溢出导致了实际结果为正,
* 如果OF为1,说明有溢出,那么逻辑上真正的结果的正负不等于实际结果的正负. 
  如果SF为1,那么实际结果为负,由前面“逻辑上真正的结果的正负不等于实际结果的正负”可知,逻辑上真正的结果应该为正. 
  可得出结论：如果因为溢出导致了实际结果为负,那么逻辑上真正的结果必然为正.
  十进制 十六进制 
  45+100=145 
  mov al,45 mov al,2d 
  add al,100 add al,64 
  al的值应为145, al的值为 91h ,二进制表示为1001 0001, 
  8位二进制能表达的数据范围-128至127,of=1 因此,sf=1因为溢出导致了实际结果为负
  0110 1111(111的补码)
  1001 0000(取反了)
  1001 0001(加1了,得到-110的补码)即91h
* 如果OF为0,说明没有溢出,那么逻辑上真正的结果的正负等于实际结果的正负. 
  如果SF为0,实际结果正,所以逻辑上真正的结果正.

#### SF	符号标志

SF=0（最高位是什么,SF就是什么）

#### DF	方向标志

| DF=0 | 每次操作后si++，di++ | 正方向 | 源地址>目标地址 |
| :--: | :------------------: | :----: | :-------------: |
| DF=1 | 每次操作后si--，di-- | 反方向 | 源地址<目标地址 |

#### IF	中断标志

IF=1，允许中断，否则禁止中断

cli	sti指令

## 一些杂七杂八的细节

### call的原理

先将call后面的一行代码的偏移地址压入堆栈，然后jmp，遇到ret后，pop 堆栈进入ip（32位弹如eip），从而使程序知道跳入哪段代码，从而jmp到后面的代码

### 注意引用dw类型数组时的下标

```assembly
data segment
abc db 1,2,3,4
xyz dw 789Ah, 0BCDEh
asd dd 12345678h, 56789ABCh; 首元素为asd[0]
                           ; 末元素为asd[4]
data ends
```

在引用xyz中第二个元素时要注意下标

```assembly
mov ax, xyz[2] ;\编译后变成:
mov ax, [xyz+2];/mov ax, ds:[6]
```

### mov指令不影响任何标志位

### FL和IP寄存器在编程时不能直接引用

### div运算相关

商默认放在al中，余数默认放在ah中，也就是说在除法运算中，被除数会被损坏

### 堆栈入栈和出栈时的动作先后顺序

#### 入栈

先sp减小2，再把push后面的数值保存到ss:sp指示的地方

#### 出栈

先取出ss:sp中内容，再sp加2恢复

#### 关于堆栈

> 注意入栈sp是减而不是加！
>
> 注意push和pop只能对16位字和32位双字操作，不能对8位字节进行操作

### 两组段地址应用
cs:ip 指向当前要执行的命令

ss:sp 指向堆栈顶端

### 32位汇编相关

* 32位汇编中，[]中有ebp和esp时，段地址为ss，否则段地址为ds
* 32位比16位多了以下这种寻址方式：[寄存器+寄存器*n+常数]（其中n=2、4、8）
* 32位汇编对[]中寄存器不做限制，但是段寄存器，ip寄存器，fl寄存器不能放在方括号中
* 32位汇编起允许push一个常数

### 参数传递时的堆栈传递

![recursion](E:\浙江大学\课程文件\大二春夏课程\汇编语言程序设计基础-白洪欢\Lecture_2017_2018_Autumn_Winter\recursion.PNG)

## 几个典型程序和它们反映的问题

### 程序1：es 附加段，它跟ds 类似，可以用来表示一个数据段的址。

```assembly
;es: extra segment 附加段，它跟ds 类似，可以用来表示一个数据段的址。下面是示例程序
data1 segment
abc db 1,2,3
data1 ends

data2 segment
xyz db 4,5,6
data2 ends

code segment
assume cs:code, ds:data1, es:data2
main:
   mov ax, data1
   mov ds, ax
   mov ax, data2
   mov es, ax
   mov ah, abc[1]; 编译后变成mov ah, ds:[1]
   ;也可以写成mov ah, ds:abc[1]
   mov xyz[1], ah; 编译后变成mov es:[1], ah
   ;也可以写成mov es:xyz[1], ah
   ;错误写法:mov abc[1], xyz[1]; 因两个对象不能都为内存变量
   mov ah, 4Ch
   int 21h
code ends
end main
```

### 例二:输入2个2位的16进制数，输出他们的和，**<font color="red">需要实际调试学习 </font>**

```assembly
;例1
;输入2个2位的16进制数，输出他们的和
;例如输入FF02,则输出0101
.386
code segment use16
assume cs:code
input:
        ;汇编中定义函数与定义标号的方法一样
        ;也即，函数名就是一个标号
        mov
ah,1
        int 21h;AL=getchar()
        cmp al,'A';'A'==41h,'9'==39h
        jb
is_digit
is_alpha:
        sub al,'A'
        add
al,10
        jmp
input_done
is_digit:
        sub al,'0';AL是函数的返回值
input_done:
        ret
        ;至此，是实现了单个字符输入斌并转换
input_a_number:
        call
input;输入十位并转换
        mov
bl,al
        call
input；输入个位并转换
        shl
bl,4;左移4位
        add
al,bl;AL是函数的返回值
        pop bx;保护数据
        ret
output_a_number:
        ;下面展示了通过循环左移的手法先输出高位后输出低位
        ;进而实现输出结果的手法
        mov
cx,4
;1011 0000 1111 0101        循环左移前
;0000 1111 0101 1011        循环左移后
convert_next_digit:
        rol
ax,4;循环左移4位
        push ax
        and ax,0Fh;AX=0000
0000 0000 1011
        cmp al,10
        jb
output_is_digit
        sub al,10
        add
al,'A'
        jmp
output_a_digit
output_is_digit:
        add
al,'0'
output_a_digit:
        mov
ah,2
        mov
dl,al
        int 21h;putchar(AL)
        pop ax
        sub cx,1
        jnz
convert_next_digit
        pop dx
        pop cx
        ret
main:
        call
input_a_number
        mov
bh,0
        mov
bl,al;BX=00FF
        ;上面两行保存了输入的第一个数的值
        call
input_a_number
        mov
ah,0;AX=0002
        add
ax,bx;计算两数之和
        call
output_a_number;以16进制格式输出AX值
        mov
ah,4Ch
        int 21h
code ends
end main
```

